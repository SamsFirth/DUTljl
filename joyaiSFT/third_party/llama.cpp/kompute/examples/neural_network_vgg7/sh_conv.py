import os
import kp

def compile_source(source):
    os.system('glslangValidator --stdin -S comp -V -o tmp_kp_shader.comp.spv << END\n' + source + '\nEND')
    return open('tmp_kp_shader.comp.spv', 'rb').read()
global conv_shader
conv_shader = compile_source("\n#version 450\n\nlayout (local_size_x = 8, local_size_y = 2) in;\n\n// [y][x][group] (vec4: channels)\nlayout (set = 0, binding = 0) buffer buf_in_image { readonly restrict vec4 in_image[]; };\n// [outputCGroups] (vec4: output channels)\nlayout (set = 0, binding = 1) buffer buf_in_bias { readonly restrict vec4 in_bias[]; };\n// [outputCGroups][kernelH][kernelW][inputCGroups] (mat4: input & output channels)\nlayout (set = 0, binding = 2) buffer buf_in_weight { readonly restrict mat4 in_weight[]; };\n// [y][x][group] (vec4: channels)\nlayout (set = 0, binding = 3) buffer buf_out_image { writeonly restrict vec4 out_image[]; };\n\n// The 'c' measures in cgroups.\n// Some maths changes as a result.\nlayout (constant_id = 0) const float in_w = 0;\nlayout (constant_id = 1) const float in_h = 0;\nlayout (constant_id = 2) const float in_cg = 0;\nlayout (constant_id = 3) const float out_w = 0;\nlayout (constant_id = 4) const float out_h = 0;\nlayout (constant_id = 5) const float out_cg = 0;\n\nuint index_in_no_ic(uvec2 pos) {\n    return (pos.x + (pos.y * uint(in_w))) * uint(in_cg);\n}\n\nuint index_out(uvec2 pos) {\n    return ((pos.x + (pos.y * uint(out_w))) * uint(out_cg)) + gl_GlobalInvocationID.z;\n}\n\nvoid main() {\n    // out x/y is gl_GlobalInvocationID.xy\n    // we need to account for workgroupy padding *here*\n    // so long as we aren't trying to output to a pixel that doesn't exist,\n    //  we won't read from any pixels that don't exist\n    if (\n        (gl_GlobalInvocationID.x < (uint(in_w) - 2)) &&\n        (gl_GlobalInvocationID.y < (uint(in_h) - 2))\n    ) {\n        vec4 value = in_bias[gl_GlobalInvocationID.z];\n        for (uint x = 0; x < 3; x++) {\n            for (uint y = 0; y < 3; y++) {\n                uint weight_ptr = ((gl_GlobalInvocationID.z * 9) + (x + (y * 3))) * uint(in_cg);\n                // specific pixel\n                // important to note is that since in position has a border around it,\n                // no further transformation is necessary (the - is implied)\n                uvec2 in_pos = gl_GlobalInvocationID.xy + uvec2(x, y);\n                uint in_ptr = index_in_no_ic(in_pos);\n                for (uint icg = 0; icg < uint(in_cg); icg++) {\n                    // input channel group\n                    vec4 iCG = in_image[in_ptr];\n                    // handle all 4 input components\n                    value += iCG * in_weight[weight_ptr];\n                    weight_ptr += 1;\n                    in_ptr += 1;\n                }\n            }\n        }\n        // leakyrelu slope 0.1\n        value = (max(value, 0.0) * 0.9) + (value * 0.1);\n        out_image[index_out(gl_GlobalInvocationID.xy)] = value;\n    }\n}\n")